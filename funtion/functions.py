# def fname():
#     set of statments
# call()  calling function name


# fn without arguements and no return type
# fn with arguements and no return type
# fn with arguements and return type

# 1)fn withour arguements and no return type

# def add():
#     num1=int(input("enter the number"))
#     num2=int(input("enter the number"))
#     sum=num1+num2
#     print(sum)
# add()
# add()
# add()


# def mul():
#     num1=int(input("enter the number"))
#     num2=int(input("enter the number"))
#     pro=num1*num2
#     print(pro)
# mul()

# functional programming
#
# lambda
# map
# filter
# reduce
# list comprehension

# 2)fn with arguements and no return type

# def sum(num1,num2):
#     res=num1+num2
#     print(res)
# sum(10,20)
# sum(25,54)

# def div(num1,num2):
#     res=num1/num2
#     print(res)
# div(10,20)
# div(99,11)

# 3)fn with arguements and  return type

# def sum(num1,num2):
#     res=num1*num2
#     return res
# data=sum(3,5)
# print(data)
# data=sum(3,6)
# print(data)



# def sub():
#     num1=int(input("enter 1st no"))
#     num2=int(input("enter 2nd no"))
#     total=num2-num1
#     print(total)
# sub()


# def sub(num1,num2):
#     res=num2-num1
#     print(res)
# sub(12,65)


# def sub(num1,num2):
#     res=num2-num1
#     return res
# data=sub(32,97)
# print(data)

# def fact():
#     num=int(input("enter a num"))
#     pro=1
#     for i in range(1,num+1):
#         pro=pro*i
#     print(pro)
# fact()



# def cube_2(num1):
#     pro=num1*num1*num1
#     return pro
# data=cube_2(8)
# print(data)

